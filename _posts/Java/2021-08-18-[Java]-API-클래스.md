---
title:  "[Java] API 클래스"

categories: java
tags: java

toc: true
toc_sticky: true

date: 2021-08-18 21:50:05
---

# Object 클래스

**java.lang** 패키지

- 가장 기본적인 동작을 수행하는 클래스들의 집합
- 이 패키지의 클래스들은 import문 없이 클래스 이름만으로 바로 사용 가능

**java.lang.Object** 클래스

- Object클래스는 모든 자바 클래스의 최고 조상 클래스
- 모든 자바 클래스는 Object클래스의 모든 메소드를 바로 사용 가능
- Object크래스는 필드를 가지지 않고, 11개의 메소드로 구성

## toString() 메소드

- 해당 인스턴스에대한 정보를 문자열로 반환
- 반환되는 문자열은 클래스 이름과 함께 구분자로 '@'가 사용되고, 뒤로 16진수 해시코드가 추가됨
- 16진수 해시 코드 값은 인스턴스의 주소를 가리키는 값, 인스턴스마다 다르게 반환

```java
Car car01 = new Car();
Car car02 = new Car();
 
System.out.println(car01.toString());
System.out.println(car02.toString());
```

## equals() 메소드

- 해당 인스턴스를 메개변수로 전달받는 참조 번수와 비교하고, 결과 반환
- 참조 변수가 가리키는 값을 비교함, 서로 다른 두 객체는 항상 false

```java
Car car01 = new Car();
Car car02 = new Car();
 
System.out.println(car01.equals(car02)); //false
car01 = car02; // 두 참조 변수가 같은 주소를 가리킴.
System.out.println(car01.equals(car02)); //true
```

## clone() 메소드

- 해당 인스턴스를 복제하여, 새로운 인스턴스를 생성하여 반환
-  Object 클래스의 clone() 메소드는 단지 필드의 값만을 복사, 필드의 값이 배열이나 인스턴스면 제대로 복제할 수 없음, 이러한 경우에는 해당 클래스에서 clone() 메소드를 오버라이딩하여, 복제가 제대로 이루어지도록 재정의해야함

```java
import java.util.*;

class Car implements Cloneable {
    private String modelName;
    private ArrayList<String> owners = new ArrayList<String>();
    public String getModelName() { return this.modelName; }                    // modelName의 값을 반환함
    public void setModelName(String modelName) { this.modelName = modelName; } // modelName의 값을 설정함
 
    public ArrayList getOwners() { return this.owners; }                      // owners의 값을 반환함
    public void setOwners(String ownerName) { this.owners.add(ownerName); }   // owners의 값을 추가함
 
    public Object clone() {
        try {
           Car clonedCar = (Car)super.clone();
           // clonedCar.owners = (ArrayList)owners.clone();
            return clonedCar;
       } catch (CloneNotSupportedException ex) {
            ex.printStackTrace();
            return null;
        }
    }
}
 
public class Object03 {
    public static void main(String[] args) {
        Car car01 = new Car();
        car01.setModelName("아반떼");
        car01.setOwners("홍길동");
        System.out.println("Car01 : " + car01.getModelName() + ", " + car01.getOwners() + "\n");
        
        Car car02 = (Car)car01.clone();

        car02.setOwners("이순신");
        System.out.println("Car01 : " + car01.getModelName() + ", " + car01.getOwners());
        System.out.println("Car02 : " + car02.getModelName() + ", " + car02.getOwners());
    }
}
```

> //주석 해제 x
>
> Car01 : 아반떼, [홍길동]
>
>  
>
> Car02 : 아반떼, [홍길동, 이순신]
>
> Car02 : 아반떼, [홍길동, 이순신]
>
> 
>
> //주석 해제
>
> Car01 : 아반떼, [홍길동]
>
>  
>
> Car02 : 아반떼, [홍길동]
>
> Car02 : 아반떼, [홍길동, 이순신]

이렇게 출력이나온다. 

부모 클래스의 clone() 메소드를 호출하여 clone() 메소드를 재정의하면, 

배열이나 인스턴스인 필드는 복제되는 것이 아닌 해당 배열이나 인스턴스를 가리키는 **주소값**만이 복제되는 것입니다.

# String 클래스

**java.lang.String** 클래스

- String인스턴스는 한 번 생성되면 값을 읽기만 할 수 있고, 변경할수 없음
- 문자열을 위한 String 클래스

## charAt() 메소드

- 해당 문자열의 특정 인덱스에 해당하는 문자 반환
- 해당 문자열의 길이보다 큰 인덱스나 음수를 전달하면, IndexOutBoundsException오류남

```java
String str = new String("Java");
System.out.println("원본 문자열 : " + str); //java
 
for (int i = 0; i < str.length(); i++) {
    System.out.print(str.charAt(i) + " "); //j a v a
}
System.out.println("\ncharAt() 메소드 호출 후 원본 문자열 : " + str);//java
```

## compareTo() 메소드

- 해당 문자열을 인수로 전달된 문자열과 사전 순으로 비교
- 두 문자열이 같다면 0을 반환하며, 해당 문자열이 인수로 전달된 문자열보다 작으면 음수를, 크면 양수를 반환
- 소문자를 구분하지 않기를 원한다면, compareToIgnoreCase() 메소드를 사용

```java
String str = new String("abcd");
System.out.println("원본 문자열 : " + str); //abcd
 
System.out.println(str.compareTo("bcef")); //-1
System.out.println(str.compareTo("abcd") + "\n"); //0

System.out.println(str.compareTo("Abcd")); //32
System.out.println(str.compareToIgnoreCase("Abcd"));//0
System.out.println("compareTo() 메소드 호출 후 원본 문자열 : " + str);//abcd
```

\+ 내일 더 추가 예정